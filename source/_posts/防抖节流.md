---
title: 手写js防抖节流
tags: javascript
---


### 防抖

浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。为了优化体验，需要对这类事件进行调用次数的限制。
作用是在短时间内多次触发同一个函数，只执行最后一次，或者只在开始时执行。以用户拖拽改变窗口大小，触发 resize 事件为例，在这过程中窗口的大小一直在改变，所以如果我们在 resize 事件中绑定函数，这个函数将会一直触发，而这种情况大多数情况下是无意义的，还会造成资源的大量浪费。
```javascript
const input1 = document.getElementById('input1')
let timer = null
input1.addEventListener('keyup',function(){
	if(timer){
		clearTimeout(timer)
	}
	timer = setTimeout(() => {
    console.log(input1.value)
    	timer = null
	},500)

})

function debounce(fn,delay=500) {
	let timer = null // timer 在闭包里
	// console.log(this) // window
   return function() {
   	if (timer) {
		clearTimeout(timer)
	}
	timer = setTimeout(() => {
         fn.apply(this,arguments);// 这里使用绑定this的会更全面，但是下面就不能用箭头函数
         console.log(arguments)
         console.log(this)
         timer = null
	},delay)
   }
}
// 闭包在什么时候用呢，函数作为返回值，函数作为传入的参数
input1.addEventListener('keyup',debounce(function(){
	// 箭头函数并没有自己的执行上下，它的this是根据父函数走的，所以箭头函数使用apply(this)这种可能会丢失第一个参数
	 console.log(input1.value)
   
},1000))
var arr = (a) => {
   console.log(this, a)
};
var b = {c:3};
arr(3);
arr.call(b,3);
```
这里两种输出的this都是window，this绑不绑都一样。

### 节流
```javascript
const div1 = document.getElementById('div1')
let timer = null 
div1.addEventListener('drag',function(e){
	if(timer) {
		return
	}
	timer = setTimeout(() => {
		console.log(e.offsetX, e.offsetY)
		timer = null
	},100)
})

function throttle(fn,delay=100){
	let timer = null 
	return function(){
	if(timer){
		return
	}
	timer = setTimeout(() => {
		fn.apply(this,arguments)
		timer = null
	},delay)
	}
}
div1.addEventListener('drag',throttle(function(e){ 
	//这里函数的参数会传给包裹的函数返回的函数，所以需要绑定this和参数才能被返回的函数执行
	console.log(e.offsetX, e.offsetY);
},100))
```