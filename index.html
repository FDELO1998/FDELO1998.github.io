<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="core"><title>FDELO</title><meta name="description" content="只有自己能决定成为什么样的人。&lt;br&gt; Nothing is impossible to a willing heart."><meta name="keywords" content="fdelo1998"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">FDELO</a></h3><div class="description"><p>只有自己能决定成为什么样的人。<br> Nothing is impossible to a willing heart.</p></div></div></div><ul class="social-links"><li><a href="https://github.com/fdelo1998" target="_blank" rel="noopener"><i class="fa fa-github"></i></a></li><li><a href="fdelo1998@163.com"><i class="fa fa-envelope"></i></a></li><li><a href="http://sighttp.qq.com/authd?IDKEY=273601249" target="_blank" rel="noopener"><i class="fa fa-qq"></i></a></li></ul><div class="footer"><div class="p"> <span>© 2020-未来 </span><i class="fa fa-star"></i><span> core</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core.  </a><a href="http://www.beian.miit.gov.cn/" target="_blank">&nbsp;粤ICP备15011643号</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a class="current" href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li><li><a href="/guestbook">留言</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/06/25/ES6-this%E6%8C%87%E5%90%91%E5%92%8Cnew%E5%8E%9F%E7%90%86/">this和new过程</a></h3></div><div class="post-content"><p>话不多说，全面整理一下各个状态下的this指向，并对原理做一些分析
1.普通函数1234567let a = function() &#123;	console.log(this)&#125;let b=()=&gt;&#123;	console.log(this)&#125;a(),b()
全局作用域调用的，所...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-06-25</span><i class="fa fa-tag"></i><a class="tag" href="/tags/ES6/" title="ES6">ES6 </a><span class="leancloud_visitors"></span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/06/24/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/">手写js防抖节流</a></h3></div><div class="post-content"><p>防抖浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。为了优化体验，需要对这类事件进行调用次数的限制。作用是在短时间内多次触发同一个函数，只执行最后一次，或者只在开始时执行。以用户拖拽改变窗口大小，触发 r...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-06-24</span><i class="fa fa-tag"></i><a class="tag" href="/tags/javascript/" title="javascript">javascript </a><span class="leancloud_visitors"></span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/06/20/js-event%20loop/">event-loop</a></h3></div><div class="post-content"><p>event loop事件循环是异步回调的实现原理（机制）,js代码的执行一行一行来，遇错停止，先同步后异步。
事件循环过程：四个模块（call stack调用栈 ，Web APIs浏览器定义的API，callback Queue回调队列, event loop一般情况：同步代码推入调用栈，执行完清空。有定时任务执...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-06-20</span><i class="fa fa-tag"></i><a class="tag" href="/tags/javascript/" title="javascript">javascript </a><span class="leancloud_visitors"></span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/06/15/react%E7%AC%94%E8%AE%B01/">React笔记1</a></h3></div><div class="post-content"><p>非受控组件组件状态不受this.state控制，通过ref直接操作dom的组件。
函数组件函数组件，没有实例，没有state，this,没有生命周期，只有props。函数组件可以捕获render内部的状态，依靠js的闭包实现的。通常搭配hooks，函数组件也可以有state和类生命周期的回调。
性能优化shoul...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-06-15</span><i class="fa fa-tag"></i><a class="tag" href="/tags/React/" title="React">React </a><span class="leancloud_visitors"></span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/06/12/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">react 生命周期总结</a></h3></div><div class="post-content"><p>react目前市面上使用的主要是v16前的生命周期，和v16之后的。所以我们应当都掌握一下。
React v16.0 前的生命周期主要分为Initialization,Mounting,Updation,Unmounting。初始化阶段：主要是构造函数这些方法使用，包括定义的类继承react component基...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-06-12</span><i class="fa fa-tag"></i><a class="tag" href="/tags/React/" title="React">React </a><span class="leancloud_visitors"></span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/06/05/js-call%E7%AD%89%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0/">手写bind apply call 函数</a></h3></div><div class="post-content"><p>首先简单说一下bind apply call在传参和返回值上的区别。bind 和 call第一个参数为要指向的对象，如果不传this指向window。后面的参数bind可以挨个往里面传,而call是要一次性传入。apply后面的参数要以数组方式传入。返回，apply和call都是直接返回改变了this的结果，而b...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-06-05</span><i class="fa fa-tag"></i><a class="tag" href="/tags/javascript/" title="javascript">javascript </a><span class="leancloud_visitors"></span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/05/16/js-async/">详细理解async和await</a></h3></div><div class="post-content"><p>async首先从定义上，是异步的简写，而await可以认为是async wait的简写。所以可以很好的理解为async使用声明一个function是异步的，await用来等待一个异步方法执行完成。 语法规定就是await只能在async中间使用。async起的作用就是将函数（函数语句，函数表达式，lambda表达...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-05-16</span><i class="fa fa-tag"></i><a class="tag" href="/tags/javascript/" title="javascript">javascript </a><span class="leancloud_visitors"></span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/04/28/react-%E5%AD%A6%E4%B9%A0/">react 学习</a></h3></div><div class="post-content"><p>react函数式组件 react的组件利用类似函数定义的方式去实现的如：
1234567function Clock(props)&#123;  return (     &lt;div&gt;       &lt;h1&gt;现在的时间是&#123;props.date.toLocaleTimeString()...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-04-28</span><i class="fa fa-tag"></i><a class="tag" href="/tags/React/" title="React">React </a><span class="leancloud_visitors"></span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/04/27/js-%E8%B7%A8%E5%9F%9F/">跨域资源共享</a></h3></div><div class="post-content"><p>首先什么叫跨域：跨域来源于同源策略，也就是限制一个源加载的文档或脚本如何与来自另一个源的资源进行交互。同源策略是保护隔离潜在恶意文件的关键的安全机制。定义为：一个脚本向后台申请数据时只能读取同一协议名，同一主机名，同一端口号下的数据。当不满足上述条件时，我们称为违背同源策略，这时候就要进行跨域。
实现跨域的方法主...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-04-27</span><i class="fa fa-tag"></i><a class="tag" href="/tags/javascript/" title="javascript">javascript </a><span class="leancloud_visitors"></span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/04/16/http2.0/">http2.0</a></h3></div><div class="post-content"><p>最近面试挺多公司会问问http1.0和2.0的区别。所以我想总结一下http2.0。目前主流的http1在1999年发布后就没有什么大的改动。随着互联网的发展，http1.0在很多时候也是力不从心。所以负责互联网技术的互联网工程任务组在14年推进http2.0标准化。http2.0主要体现在以下几种技术：1.压缩...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-04-16</span><i class="fa fa-tag"></i><a class="tag" href="/tags/HTTP/" title="HTTP">HTTP </a><span class="leancloud_visitors"></span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/2/">下一页</a></li></ul></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script></body></html>