<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="core"><title>FDELO</title><meta name="description" content="只有自己能决定成为什么样的人。&lt;br&gt; Nothing is impossible to a willing heart."><meta name="keywords" content="fdelo1998"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">FDELO</a></h3><div class="description"><p>只有自己能决定成为什么样的人。<br> Nothing is impossible to a willing heart.</p></div></div></div><ul class="social-links"><li><a href="https://github.com/fdelo1998" target="_blank" rel="noopener"><i class="fa fa-github"></i></a></li><li><a href="fdelo1998@163.com"><i class="fa fa-envelope"></i></a></li><li><a href="http://sighttp.qq.com/authd?IDKEY=273601249" target="_blank" rel="noopener"><i class="fa fa-qq"></i></a></li></ul><div class="footer"><div class="p"> <span>© 2020-未来 </span><i class="fa fa-star"></i><span> core</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core.  </a><a href="http://www.beian.miit.gov.cn/" target="_blank">&nbsp;粤ICP备15011643号</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a class="current" href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li><li><a href="/guestbook">留言</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/06/29/React%E9%80%9A%E4%BF%A1%E5%8F%8A%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/">React通信及状态管理（类和函数组件，最新hook等</a></h3></div><div class="post-content"><p>最近学习了React，但是对于其所有的通信方式和状态管理处于有点混乱的状态。所以准备系统的整理一下。包括现在项目中主要使用的函数组件搭配hook也一起整理下。话不多说，先从简单的开始。
父向子组件通信这个部分比较好理解，通过属性传递。简单一个例子
12345678910111213141516import Rea...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-06-29</span><i class="fa fa-tag"></i><a class="tag" href="/tags/React/" title="React">React </a><span class="leancloud_visitors"></span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/06/27/react%E5%8E%9F%E7%90%86/">React原理</a></h3></div><div class="post-content"><p>JSX等同于Vue模板，就是createElement函数jsx语法根本是无法被浏览器解析的，也无法直接运行都是要通过转化为js才可以运行。所以说在使用react的时候要import react。然后看解析过程：
1234567891011121314151617181920212223242526272829r...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-06-27</span><i class="fa fa-tag"></i><a class="tag" href="/tags/React/" title="React">React </a><span class="leancloud_visitors"></span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/06/26/%E8%99%9A%E6%8B%9FDOM%E5%92%8Cdiff/">虚拟DOM和diff</a></h3></div><div class="post-content"><p>DOM操作是非常耗费性能的，对于现在热门的框架vue react（数据驱动视图）来说，如何有效控制DOM操作
vdom - 用js模拟DOM结构，计算最小变更，操作DOM用js模拟DOM结构，比如：
123456&lt;div id="div1" class="con"&gt; &lt;p&gt;vdom&lt;...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-06-26</span><i class="fa fa-tag"></i><a class="tag" href="/tags/DOM/" title="DOM">DOM </a><span class="leancloud_visitors"></span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/06/25/ES6-this%E6%8C%87%E5%90%91%E5%92%8Cnew%E5%8E%9F%E7%90%86/">this和new过程</a></h3></div><div class="post-content"><p>话不多说，全面整理一下各个状态下的this指向，并对原理做一些分析
1.普通函数1234567let a = function() &#123;	console.log(this)&#125;let b=()=&gt;&#123;	console.log(this)&#125;a(),b()
全局作用域调用的，所...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-06-25</span><i class="fa fa-tag"></i><a class="tag" href="/tags/ES6/" title="ES6">ES6 </a><span class="leancloud_visitors"></span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/06/24/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/">手写js防抖节流</a></h3></div><div class="post-content"><p>防抖浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。为了优化体验，需要对这类事件进行调用次数的限制。作用是在短时间内多次触发同一个函数，只执行最后一次，或者只在开始时执行。以用户拖拽改变窗口大小，触发 r...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-06-24</span><i class="fa fa-tag"></i><a class="tag" href="/tags/javascript/" title="javascript">javascript </a><span class="leancloud_visitors"></span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/06/20/js-event%20loop/">event-loop</a></h3></div><div class="post-content"><p>event loop事件循环是异步回调的实现原理（机制）,js代码的执行一行一行来，遇错停止，先同步后异步。
事件循环过程：四个模块（call stack调用栈 ，Web APIs浏览器定义的API，callback Queue回调队列, event loop一般情况：同步代码推入调用栈，执行完清空。有定时任务执...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-06-20</span><i class="fa fa-tag"></i><a class="tag" href="/tags/javascript/" title="javascript">javascript </a><span class="leancloud_visitors"></span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/06/05/js-call%E7%AD%89%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0/">手写bind apply call 函数</a></h3></div><div class="post-content"><p>首先简单说一下bind apply call在传参和返回值上的区别。bind 和 call第一个参数为要指向的对象，如果不传this指向window。后面的参数bind可以挨个往里面传,而call是要一次性传入。apply后面的参数要以数组方式传入。返回，apply和call都是直接返回改变了this的结果，而b...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-06-05</span><i class="fa fa-tag"></i><a class="tag" href="/tags/javascript/" title="javascript">javascript </a><span class="leancloud_visitors"></span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/06/01/%E6%89%8B%E5%86%99%E6%B7%B1%E5%BA%A6%E6%AF%94%E8%BE%83/">深度比较</a></h3></div><div class="post-content"><p>最近在看js浅比较和深比较。手动实现一个，捋一下思路
12345678910111213141516171819202122232425262728293031323334function ifObject(obj)&#123;   return typeof obj == 'object' &amp;&amp;...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-06-01</span><i class="fa fa-tag"></i><a class="tag" href="/tags/javascript/" title="javascript">javascript </a><span class="leancloud_visitors"></span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/05/31/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">react 生命周期总结</a></h3></div><div class="post-content"><p>react目前市面上使用的主要是v16前的生命周期，和v16之后的。所以我们应当都掌握一下。
React v16.0 前的生命周期主要分为Initialization,Mounting,Updation,Unmounting。初始化阶段：主要是构造函数这些方法使用，包括定义的类继承react component基...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-05-31</span><i class="fa fa-tag"></i><a class="tag" href="/tags/React/" title="React">React </a><span class="leancloud_visitors"></span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/05/16/js-async/">详细理解async和await</a></h3></div><div class="post-content"><p>async首先从定义上，是异步的简写，而await可以认为是async wait的简写。所以可以很好的理解为async使用声明一个function是异步的，await用来等待一个异步方法执行完成。 语法规定就是await只能在async中间使用。async起的作用就是将函数（函数语句，函数表达式，lambda表达...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-05-16</span><i class="fa fa-tag"></i><a class="tag" href="/tags/javascript/" title="javascript">javascript </a><span class="leancloud_visitors"></span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/2/">下一页</a></li></ul></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script></body></html>